created: 20200505103654306
modified: 20200626151438884
tags: 树
title: 二叉树
type: text/vnd.tiddlywiki

二叉树 (Binary Tree) 表示''每个节点最多有两个孩子节点的树。''通常两个子树被称为''左子树''和''右子树''。

> 与普通的树不同，二叉树的左右分支有顺序，不能随意颠倒。


!! 计算

* 二叉树的第 $$i$$ 层至多有 $$2^{i-1}$$ 个节点。
* 深度为 $$k$$ 的二叉树，最多总共有 $$2^k-1$$ 个节点(根节点深度为 $$0$$ ）。总计节点数符合的称为''满二叉树''；
* 对于任意一个非空的二叉树，如果叶子节点为 $$n_0$$ 个，度为 $$2$$ 的节点个数为 $$n_2$$ 个，则 $$n_0 = n_2 + 1$$。

二叉树可以用来实现 [[二叉搜索树]] 和 [[二叉堆]] ，实现高效率的排序和搜索。


!! 特殊类型

||!完全二叉树|!满二叉树|
|!总节点 $$k$$| $$2^{k-1}\le k \le 2^k-1$$ | $$2^k-1$$ |
|!树的高度| $$log_2k+1$$ | $$log_2{(k+1)}$$ |

!!! 满二叉树

深度为 $$k$$ 节点个数为 $$2^k-1$$ 的树称为''满二叉树(Full Binary Tree)''。这种树的特点是''每一层上的节点数都是最大节点数。''

[img[full_binary_tree]]


!!! 完全二叉树

在一颗树中，除最后一层外，其他层都是满的，而且最后一层是在右边缺少连续若干节点，则此二叉树为完全二叉树（Complete Binary Tree）。

具有 $$n$$ 个节点的完全二叉树的深度为 $$log_2n+1$$。深度为 $$k$$ 的完全二叉树，至少有 $$2^{k-1}$$ 个节点，至多有 $$2^k-1$$ 个节点。

[img[complete_binary_tree]]



!! 存储

!!! 顺序表示

二叉树可以采用[[数组|顺序表]]保存，如果是满二叉树或者完全二叉树，就能够排列紧凑而不浪费空间。

如果某个节点在数组中的索引为 $$i$$，那么他的：

* 左子节点：$$2i+1$$
* 右子节点：$$2i+2$$
* 父节点：$$\left [ \frac{i-1}{2} \right ]$$

<<note "<div>

通常，会将数组索引为 `0` 的位置舍弃，这样更方便计算，如果一个节点为 $$i$$，那么：

* 左子节点: $$2i$$
* 右子节点: $$2i+1$$
* 父节点: $$\frac{i}{2}$$

</div>">>
优点：利于紧凑存储和更好的访问局限性。

缺点：普通的二叉树，会浪费更大的空间。

> 假如一个树只有右节点，那么存储为顺序结构就需要 $$2^h-1$$ 的空间，但实际上却只有 $$h$$ 个节点。


!!! 二叉链表

[[链表]] 是比较常用的树的存储结构。在这个链表中，每个节点包含两个指针，分别指向左孩子和右孩子。

使用二叉链表时''不能像顺序表示一样随机访问。'' 且二叉链表的节点中没有指向父节点的指针，在需要父节点时就''得从根节点重新遍历。''

!!! 三叉链表

三叉链表在二叉链表的基础上增加了父节点的指针，能够更好的实现节点之间的访问，不过算法相对复杂。


!! 遍历

我们经常希望访问树中的每一个结点并且查看它的值。有很多常见的顺序来访问所有的结点，而且每一种都有有用的性质。

!!! 深度优先遍历

深度优先遍历的意思是，我们优先从根节点访问距离最远的节点。和[[图的深度遍历|图]]不同，树的遍历不需要记住经过的每一个节点，因为树中''不可能有环''。

> 前序，中序和后序遍历都是深度优先遍历的特例。

使用 L、D、R 分表表示''遍历左子树，访问根节点，遍历右子树''。

* ''前序遍历''：D L R
* ''中序遍历''：L D R
* ''后序遍历''：L R D

<<info "这些方法的时间复杂度都是 $$O(n)$$。">>


!!! 广度优先遍历

与深度优先不同，广度优先表示''优先访问离根节点较近的节点''。

二叉树的广度优先遍历又称''按层次遍历''。算法借助[[队列]]实现。
